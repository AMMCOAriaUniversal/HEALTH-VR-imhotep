//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using UnityEngine;
using itk.simple;

public class DicomLoaderITK
{
	public DicomLoaderITK ()
	{
	}

	public bool load( string directory )
	{
		Debug.Log("Loading Dicoms from: " + directory);
		//Tag tagStudyInstanceUID = new Tag(0x20, 0x000d);
		//Tag tagSeriesInstanceUID = new Tag(0x20, 0x000e);

		// Read the Dicom image series
		ImageSeriesReader reader = new ImageSeriesReader ();
		VectorString series = ImageSeriesReader.GetGDCMSeriesIDs( directory );
		
		Debug.Log("\tFound " + series.Count + " series.");

		if (series.Count <= 0)
			return false;

		for (int i = 0; i < series.Count; i++)
			Debug.Log ("\t" + series[i] );

		// Get the file names for the series:
		Debug.Log("\tLoading series " + series[1]);
		VectorString fileNames = ImageSeriesReader.GetGDCMSeriesFileNames( directory, series[2] );

		Debug.Log("\tFound " + fileNames.Count + " files.");
		
		if (fileNames.Count <= 0)
			return false;
		
		//for (int i = 0; i < fileNames.Count; i++)
		//	Debug.Log ("\t" + fileNames[i] );

		reader.SetFileNames (fileNames);
		
		Image image = reader.Execute();
		UInt32 numberOfPixels = image.GetWidth () * image.GetHeight () * image.GetDepth ();

		VectorUInt32 size = image.GetSize();
		Debug.Log ("\tImage: " + image.ToString());
		Debug.Log ("\tImage Pixel Type: " + image.GetPixelID());
		Debug.Log ("\tImage number of pixels: " + numberOfPixels);

		if (image.GetDimension () != 2 && image.GetDimension () != 3)
		{
			Debug.LogWarning ( "Cannot read DICOM. Only 2D and 3D images are currently supported. Dimensions of image:: " + image.GetDimension());
			return false;
		}

		IntPtr bufferPtr;
		if( image.GetPixelID() == PixelIDValueEnum.sitkUInt16 )
		{
			bufferPtr = image.GetBufferAsUInt16();
		} else {
			Debug.LogWarning ( "Cannot read DICOM. Unsupported pixel format: " + image.GetPixelID());
			return false;
		}

		//UInt16* buffer = (UInt32*)bufferPtr.ToPointer();

		Int16[] colorsTmp = new Int16[ numberOfPixels ];
		Marshal.Copy( bufferPtr, colorsTmp, 0, (int)numberOfPixels );
		
		int origTexWidth = (int)image.GetWidth ();
		int origTexHeight = (int)image.GetHeight ();
		int origTexDepth = (int)image.GetDepth ();
		int texWidth = Mathf.NextPowerOfTwo ((int)image.GetWidth ());
		int texHeight = Mathf.NextPowerOfTwo ((int)image.GetHeight ());
		int texDepth = Mathf.NextPowerOfTwo ((int)image.GetDepth ());
		Color[] colors = new Color[ texWidth*texHeight*texDepth ];
		Debug.Log (texWidth + " " + texHeight + " " + texDepth);
		UInt16 maxCol = 0;
		int index = 0;
		for (UInt32 z = 0; z < texWidth; z++) {
			for (UInt32 y = 0; y < texHeight; y++) {
				for (UInt32 x = 0; x < texDepth; x++) {
					if( x < origTexWidth && y < origTexHeight && z < origTexDepth )
					{
						if( colorsTmp[index] > maxCol )
						{
							maxCol = (UInt16)colorsTmp[index];
						}
						
						colors[ z + y*texWidth + x*texWidth*texHeight ] = F2C( (UInt16)colorsTmp[index] );
						index ++;
					}
				}
			}
		}

		Texture3D tex = new Texture3D( texWidth, texHeight, texDepth, TextureFormat.RGBA32, false);
		tex.SetPixels(colors);
		tex.Apply();

		GameObject dicomViewer = GameObject.Find("DICOM_Plane");
		if (dicomViewer)
		{
			Renderer dicomRenderer = dicomViewer.GetComponent<Renderer>();
			dicomRenderer.material.mainTexture = tex;
			dicomRenderer.material.SetFloat("globalMaximum", (float)maxCol);
		} else { Debug.Log("Can't find obj"); }
		
		return true;
	}

	Color F2C(UInt16 value)
	{
		byte[] bytes = BitConverter.GetBytes( value );

		float R = (float)bytes[0];
		//Debug.Log (R + " " + R/255.0f);
		float G = (float)bytes[1];
//		float B = 0;
//		//Debug.Log (B + " " + B/255.0f);
//		float A = 0;
//		if( print )
//			Debug.Log (value + " " + R + " " + R/255.0f + " " + G + " " + G/255.0f + " " + bytes.GetLength(0));
		return new Color( R/255.0f, G/255.0f, 0.0f, 0.0f );
	}

}

