//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using UnityEngine;
using itk.simple;

public class DicomLoaderITK
{
	public DicomLoaderITK ()
	{
	}

	public bool load( string directory )
	{

		Debug.Log("Loading DICOMs from: " + directory);

		// Read the Dicom image series
		ImageSeriesReader reader = new ImageSeriesReader ();
		VectorString series = ImageSeriesReader.GetGDCMSeriesIDs( directory );
		
		Debug.Log("\tFound " + series.Count + " series.");

		if (series.Count <= 0)
			return false;

		for (int i = 0; i < series.Count; i++)
			Debug.Log ("\t" + series[i] );

		// Find the series with the most files:
		// DEBUG: TODO: Replace this with the possibility to choose the DICOM series in the GUI.
		int seriesToLoad = 0;
		int maximum = 0;
		for( int i = 0; i < series.Count; i++ )
		{   
		    VectorString files = ImageSeriesReader.GetGDCMSeriesFileNames( directory, series[i] );
			if( files.Count > maximum )
			{
				seriesToLoad = i;
				maximum = files.Count;
			}
		}

		// Get the file names for the series:
		Debug.Log("\tLoading series " + series[seriesToLoad]);
		VectorString fileNames = ImageSeriesReader.GetGDCMSeriesFileNames( directory, series[seriesToLoad] );

		Debug.Log("\tFound " + fileNames.Count + " files.");
		
		if (fileNames.Count <= 0)
			return false;

		reader.SetFileNames (fileNames);
		
		Image image = reader.Execute();
		UInt32 numberOfPixels = image.GetWidth () * image.GetHeight () * image.GetDepth ();

		int origTexWidth = (int)image.GetWidth ();
		int origTexHeight = (int)image.GetHeight ();
		int origTexDepth = (int)image.GetDepth ();
		int texWidth = Mathf.NextPowerOfTwo ((int)image.GetWidth ());
		int texHeight = Mathf.NextPowerOfTwo ((int)image.GetHeight ());
		int texDepth = Mathf.NextPowerOfTwo ((int)image.GetDepth ());
		Debug.Log ("\tImage: " + image.ToString());
		/*Debug.Log ("\tImage Pixel Type: " + image.GetPixelID());
		Debug.Log ("\tImage size: " + origTexWidth + "x" + origTexHeight + "x" + origTexDepth );
		Debug.Log ("\tTexture size: " + texWidth + "x" + texHeight + "x" + texDepth );
		Debug.Log ("\tImage number of pixels: " + numberOfPixels);*/
		
		Color[] colors = new Color[ texWidth*texHeight*texDepth ];		
		int maxCol = 0;
		int minCol = 65535;

		if (image.GetDimension () != 2 && image.GetDimension () != 3)
		{
			Debug.LogWarning ( "Cannot read DICOM. Only 2D and 3D images are currently supported. Dimensions of image: " + image.GetDimension());
			return false;
		}

		IntPtr bufferPtr;
		if (image.GetPixelID () == PixelIDValueEnum.sitkUInt16) {
			bufferPtr = image.GetBufferAsUInt16 ();

			Int16[] colorsTmp = new Int16[ numberOfPixels ];
			Marshal.Copy( bufferPtr, colorsTmp, 0, (int)numberOfPixels );

			int index = 0;
			for (UInt32 z = 0; z < texWidth; z++) {
				for (UInt32 y = 0; y < texHeight; y++) {
					for (UInt32 x = 0; x < texDepth; x++) {
						if( x < origTexWidth && y < origTexHeight && z < origTexDepth )
						{
							if( colorsTmp[index] > maxCol )
							{
								maxCol = (int)colorsTmp[index];
							}
							
							colors[ z + y*texWidth + x*texWidth*texHeight ] = F2C( (UInt16)colorsTmp[index] );
							index ++;
						}
					}
				}
			}

		} else if ( image.GetPixelID() == PixelIDValueEnum.sitkInt16 ) {
			bufferPtr = image.GetBufferAsInt16 ();

			Int16[] colorsTmp = new Int16[ numberOfPixels ];
			Marshal.Copy( bufferPtr, colorsTmp, 0, (int)numberOfPixels );

			int index = 0;
			for (UInt32 z = 0; z < texWidth; z++) {
				for (UInt32 y = 0; y < texHeight; y++) {
					for (UInt32 x = 0; x < texDepth; x++) {
						if( x < origTexWidth && y < origTexHeight && z < origTexDepth )
						{
							if( colorsTmp[index] > maxCol )
							{
								maxCol = (int)colorsTmp[index];
							}
							
							colors[ z + y*texWidth + x*texWidth*texHeight ] = F2C( colorsTmp[index] );

							if( colorsTmp[index] < minCol )
							{
								minCol = (int)colorsTmp[index];
								//Debug.Log( "New minimum: " + minCol + " " + colors[  z + y*texWidth + x*texWidth*texHeight ]);
							}

							index ++;
						}
					}
				}
			}

			minCol += 32768;	// Signed Int16 to unsigned Int16
			maxCol += 32768;	// Signed Int16 to unsigned Int16
		} else {
			Debug.LogWarning ( "Cannot read DICOM. Unsupported pixel format: " + image.GetPixelID());
			return false;
		}

		//UInt16* buffer = (UInt32*)bufferPtr.ToPointer();



		Texture3D tex = new Texture3D( texWidth, texHeight, texDepth, TextureFormat.RGBA32, false);
		tex.SetPixels( colors	);
		tex.Apply();

		GameObject dicomViewer = GameObject.Find("DICOM_Plane");
		if (dicomViewer)
		{
			Renderer dicomRenderer = dicomViewer.GetComponent<Renderer>();
			dicomRenderer.material.mainTexture = tex;
			dicomRenderer.material.SetFloat("globalMaximum", (float)maxCol);
			dicomRenderer.material.SetFloat("globalMinimum", (float)minCol);
			dicomRenderer.material.SetFloat("range", (float)(maxCol-minCol));
		} else { Debug.LogWarning("Can't find DICOM display object."); }
		
		return true;
	}

	Color F2C(UInt16 value)
	{
		byte[] bytes = BitConverter.GetBytes( value );

		float R = (float)bytes[0];
		float G = (float)bytes[1];
		return new Color( R/255.0f, G/255.0f, 0.0f, 0.0f );
	}
	Color F2C(Int16 value)
	{
		UInt16 valueUInt = (UInt16)((int)value + 32768);
		byte[] bytes = BitConverter.GetBytes( valueUInt  );
		
		float R = (float)bytes[0];
		float G = (float)bytes[1];
		return new Color( R/255.0f, G/255.0f, 0.0f, 0.0f );
	}

}

